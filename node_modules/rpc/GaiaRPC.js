"use strict";

var
net = require('net'),
util = require('util'),
Fiber = require('fibers'),
array_proto = []

function GaiaRPCResponse(conn, seq) {
	this._conn = conn;
	this._seq = seq;
}

GaiaRPCResponse.prototype.isEnable = function () {
	return this._conn==undefined;
}

GaiaRPCResponse.prototype.send = function () {
	if(!this._conn) {
		throw new Error('GaiaRPCResponse already sent');
		return;
	}

    var args;
    if (!util.isArray(arguments)){
        args = array_proto.slice.call(arguments,0);
        //for (var i in arguments) args.push(i);
    } else {
        args = arguments;
    }
	this._conn.send(this._seq, JSON.stringify(args));
	this._conn = undefined;
}

function GaiaRPCServerConnection(server, socket) {
	this._server = server;
	this._socket = socket;
	this._buf = new Buffer(0);
}

GaiaRPCServerConnection.prototype.send = function(seq, data) {
	if(this._socket) {
		var len = Buffer.byteLength(data);
		var buf = new Buffer(8 + len);
		buf.writeUInt32LE(len, 0);
		buf.writeUInt32LE(seq, 4);
		buf.write(data, 8);
		this._socket.write(buf);
	}
}

function GaiaRPCServer() {
	var server = this;
	this._callback = [];
	this._server = net.createServer(function(c) {
		var conn = new GaiaRPCServerConnection(server, c);
		c.on('error', function(chunk) {
		});
		c.on('data', function(chunk) {
			if(!conn._socket) return;

			if(conn._buf.length>0) {
				var buf_array = [conn._buf, chunk];
				conn._buf = Buffer.concat(buf_array);
			} else {
				conn._buf = chunk;
			}

			while(conn._buf.length>=8) {
				var len = conn._buf.readUInt32LE(0);
				if(len+4+4>conn._buf.length) break;
				var seq = conn._buf.readUInt32LE(4);
				var data = conn._buf.toString('utf8', 8, 8+len);

				if(conn._buf.length==len+4+4) {
					conn._buf = new Buffer(0);
				} else {
					conn._buf = conn._buf.slice(len+4+4);
				}

				var pos = data.indexOf(':');
				if(pos<1) {
					conn._socket.end();
					conn._socket = undefined;
					return;
				}

				var callback = conn._server._callback[data.substring(0, pos)];
				if(!callback) {
					dmerror('error rpc method not found '+data.substring(0, pos));
					conn._socket.end();
					conn._socket = undefined;
					return;
				}

				var json;
				try {
					json = JSON.parse(data.substring(pos+1));
				} catch (ex) {
					json = undefined;
				}
				if(!json) {
					dmerror('failed to parse args : '+data.substring(pos+1));
					conn._socket.end();
					conn._socket = undefined;
					return;
				}

				var args;
				if(seq==0) {
					args = [new GaiaRPCResponse(conn,seq)];
				} else {
					args = [new GaiaRPCResponse(conn, seq)];
				}
				callback.apply(undefined, args.concat(json));
			}
		});
		c.on('close', function() {
			conn.socket = undefined;
		});
	});
}

function isInt(x) {
	var y=parseInt(x);
	if (isNaN(y)) return false;
	return x==y && x.toString()==y.toString();
}

GaiaRPCServer.prototype.bind = function (name, callback) {
	if(name in this._callback) return false;
	this._callback[name] = callback;
	return true;
}

GaiaRPCServer.prototype.start = function (ep) {
	var port, host;

	if(isInt(ep)) {
		port = parseInt(ep);
	} else {
		var pos = ep.indexOf(':');
		if(pos>1) {
			host = ep.substring(0, pos);
			port = parseInt(ep.substring(pos+1));
		} else {
			port = ep;
		}
	}

	if(host) {
		this._server.listen(port, host, function() {
		});
	} else {
		this._server.listen(port, function() {
		});
	}
}

GaiaRPCServer.prototype.stop = function () {
	this._server.close(function() {
	});
}

function connect_to_server(client) {
	if(g_clients_shutdown) {
		return;
	}

	client._socket = new net.Socket();

	client._socket.on('error', function () {
	});

	client._socket.on('data', function (chunk) {
		if(client._buf.length>0) {
			var buf_array = [client._buf, chunk];
			client._buf = Buffer.concat(buf_array);
		} else {
			client._buf = Buffer(chunk);
		}

		while(client._buf.length>=8) {
			var len = client._buf.readUInt32LE(0);
			if(len+4+4>client._buf.length) break;
			var seq = client._buf.readUInt32LE(4);
			var data = client._buf.toString('utf8', 8, 8+len);

			if(client._buf.length==len+4+4) {
				client._buf = new Buffer(0);
			} else {
				client._buf = client._buf.slice(len+4+4);
			}

			if(seq in client._callbacks) {
				var  callback = client._callbacks[seq];
				delete client._callbacks[seq];

				var result;
				try {
					result = JSON.parse(data);
				} catch (ex) {
					result = undefined;
				}
				if(result) {
                    //dmlog('data:' + data + ' result:' + typeof result);
					callback.call(undefined, result);
				} else {
					dmerror('error parse '+data);
					callback(undefined)
				}
			} else {
			}
		}
	});

	client._socket.on('close', function () {
		var callbacks = client._callbacks;
		client._callbacks = {};
		client._socket = undefined
		for(var key in callbacks) {
			callbacks[key](undefined);
		}
	});

	if(client._host) {
		client._socket.connect(client._port, client._host)
	} else {
		client._socket.connect(client._port);
	}
}

var g_clients_shutdown = false;
function GaiaRPCClient(port, host) {
	this._port = port;
	this._host = host;
	this._socket = undefined;
	this._buf = new Buffer(0);
	this._seq = 1;
	this._callbacks = {};
	connect_to_server(this);
}

function isFunction(functionToCheck) {
	var getType = {};
	return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

GaiaRPCClient.prototype.getEP = function() {
	return exports.genEP(this._host, this._port);
}

GaiaRPCClient.prototype.makecall = function(method) {
	if(arguments.length<1) {
//		dmlog('error');
		return;
	}
	var args = [];
	var stop = arguments.length;
	var callback = undefined;
	if(stop>1 && isFunction(arguments[stop-1])) {
		stop -= 1;
		callback = arguments[stop];
	}
	for(var i=1; i<stop; i++) {
		args.push(arguments[i]);
	}
	var data = JSON.stringify(args);
	if(!this._socket) {
		connect_to_server(this);
		if(!this._socket) {
			callback(undefined);
			return;
		}
	}

	var seq;
	if(callback) {
		while(this._seq in this._callbacks) {
			if(this._seq>300000) {
				this._seq = 1;
			} else {
				this._seq += 1;
			}
		}
		seq = this._seq;
		this._callbacks[seq] = callback;
	} else {
		seq = 0;
	}

	var datalen = Buffer.byteLength(data,'utf8');
	var buf = new Buffer(8 + method.length + 1 + datalen);
	buf.writeUInt32LE(method.length + 1 + datalen, 0);
	buf.writeUInt32LE(seq, 4);
	buf.write(method+':', 8);
	buf.write(data, 8 + method.length + 1, 'utf8');
//	dmlog('socketsend:' + buf.toString('utf8', 8));
	this._socket.write(buf);
}
GaiaRPCClient.prototype.call = GaiaRPCClient.prototype.makecall;
GaiaRPCClient.prototype.callsync = function() {
	var ret = undefined;
	var fiber = Fiber.current;
	var args = array_proto.slice.call(arguments,0);

	args.push(function (result) {
		ret = result;
		fiber.run();
	});
	this.call.apply(this, args);
	Fiber.yield();
	return ret;
}

exports.createServer = function () {
	return new GaiaRPCServer();
}

var g_clients = {};
exports.getClient = function (ep) {
	if(ep in g_clients) {
		return g_clients[ep];
	}

	var client;
	var pos = ep.indexOf(':');
	if(pos<1) {
		client = new GaiaRPCClient(ep, undefined);
	} else {
		client = new GaiaRPCClient(parseInt(ep.substring(pos+1)), ep.substring(0, pos));
	}

	g_clients[ep] = client;
	return client;
}

var conn_timer = setTimeout(function() {
	for(var ep in g_clients) {
		var client = g_clients[ep];
		if(!client._socket) {
			connect_to_server(client);
		}
	}
}, 200);

exports.shutdownClients = function () {
	g_clients_shutdown = true;
	clearTimer(conn_timer);
	for(var ep in g_clients) {
		var client = g_clients[ep];
		if(client._socket) {
			client._socket.end();
		}
	}
}

exports.parseEP = function(ep) {
	var arr = ep.split(':');
	return {host:arr[0], port:parseInt(arr[1])};
}

exports.genEP = function(host, port) {
	if (typeof host == 'object') {
		port = host.port;
		host = host.host;
	}
	return util.format('%s:%s', host, port);
}